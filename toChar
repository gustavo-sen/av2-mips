.eqv index_num $s1
.eqv digito $s2
.eqv index_lw $a0
.eqv divisor $a1
.eqv index_sto $t9
.data
numeros: .word -256,-25,101,0
virgula: .ascii ", "
numToChar: .space 50
numero: .space 4
tam: .word 4

.text
#inicializa
li $t0 , 0 
lw $t1 , tam
sub $t1 , $t1 , 1

toChar:
beq $t0, $t1, fin
addi $t0, $t0, 1
li divisor , 10
lw $t3, numeros(index_lw)
addi index_lw, index_lw, 4
li index_num, 0
blt $t3, 0, negativo

#loop numero positivo
loop:	
		#vai fazer o loop do numero, se achar que o digito e  /0 vai pegar os registradores e armazenar em num to char
 div $t3, divisor
 mflo $t3
 mfhi digito
 addi digito, digito, 30 #adiciona 30 para tabela ascii
 sw digito, numero(index_num)
 beqz $t3, exitloop #exitloop sem sinal negativo
 addi index_num, index_num, 4
j loop

exitloopN:
#tem que salvar o "-" e  incrementar o index de store
exitloop:
j toChar
beqz $s3, toChar #caso nao esteja mandando  o numero completo, joga isso aqui pro fianla 
lw  $s3, numero(index_num)
sw $s3, numToChar(index_sto)
sub index_num, index_num, 1
addi index_sto, index_sto, 4
#salva a virgula
j exitloop

negativo: #caso o numero seja negativo ele multiplica por 2
li divisor , 10
loopN:


		#vai fazer o loop do numero, se achar que o digito e  /0 vai pegar os registradores e armazenar em num to char
 div $t3, divisor
 mflo $t3
 mfhi digito
 mul digito, digito, -1
 addi digito, digito, 30 #adiciona 30 para tabela ascii
 sw digito, numero(index_num)
 beqz $t3, exitloopN
 addi index_num, index_num, 4
j loopN
fin:
li $v0, 10
syscall
